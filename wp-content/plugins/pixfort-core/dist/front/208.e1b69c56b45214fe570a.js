"use strict";(self.webpackChunkpixfort_core=self.webpackChunkpixfort_core||[]).push([[208],{208:(t,s,i)=>{i.r(s),i.d(s,{default:()=>n});class h{constructor(t){this.elm=t,this.path=t.querySelectorAll("path"),this.numPoints=3,this.speed=.4,this.paths=[],this.pointsDir=[],this.pathsDir=[],this.min=20,this.max=80,this.inView=!1}initPoints(){for(var t=0;t<this.path.length;t++){let i=[],h=[];this.getRndInteger(this.min+1,this.max-1);const n=Math.random()*Math.PI*2;for(var s=0;s<this.numPoints;s++){h[s]=this.getRndInteger(0,1);const t=s/(this.numPoints-1)*Math.PI*2;i[s]=(Math.sin(t+n)+1)/2*100}this.paths[t]=i,this.pathsDir[t]=h}for(s=0;s<this.path.length;s++){let i="";i+=`M 0 ${this.paths[s][0]} `;for(t=0;t<this.numPoints-1;t++){const h=(t+1)/(this.numPoints-1)*100,n=h-1/(this.numPoints-1)*100/2;i+=`C ${n} ${this.paths[s][t]} ${n} ${this.paths[s][t+1]} ${h} ${this.paths[s][t+1]} `}i+="V 100 H 0",this.path[s].setAttribute("d",i)}this.loop(),this.obs()}obs(){var t=this;new IntersectionObserver((function(s,i){s.forEach((s=>{s.isIntersecting?(t.inView=!0,t.loop()):t.inView=!1}))}),{threshold:[0]}).observe(this.elm)}loop(){var t=this;setTimeout((function(){if(t.inView){for(var s=0;s<t.path.length;s++){for(var i=0;i<t.numPoints;i++){var h=t.getRndInteger(0,40)/100;t.pathsDir[s][i]>0?(t.paths[s][i]+=Math.abs(Math.sin((t.paths[s][i]-t.min)/(t.max-t.min)*Math.PI))*t.speed+h,t.paths[s][i]>=(0==s?t.max-10:t.max)&&(t.pathsDir[s][i]=0)):(t.paths[s][i]-=Math.abs(Math.sin((t.max-t.paths[s][i]-t.min)/(t.max-t.min)*Math.PI))*t.speed+h,t.paths[s][i]<=t.min&&(t.pathsDir[s][i]=1))}let n="";n+=`M 0 ${t.paths[s][0]} `;for(i=0;i<t.numPoints-1;i++){const h=(i+1)/(t.numPoints-1)*100,a=h-1/(t.numPoints-1)*100/2;n+=" ",n+="C "+a+" "+t.paths[s][i]+" "+a+" "+t.paths[s][i+1]+" "+h+" "+t.paths[s][i+1]+" "}n+="V 100 H 0",t.path[s].setAttribute("d",n)}t.loop()}}),40)}getRndInteger(t,s){return Math.floor(Math.random()*(s-t))+t}}function n(t){if(!$(t).hasClass("loaded")){new h(t).initPoints(),$(t).addClass("loaded")}}}}]);